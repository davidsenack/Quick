from ast import *
import os 

class Transpiler:
    def __init__(self):
        self.output = []

    def transpile(self, node):
        method_name = 'transpile_' + type(node).__name__
        method = getattr(self, method_name, self.generic_transpile)
        return method(node)

    def generic_transpile(self, node):
        raise Exception(f'No transpile_ method defined for {type(node).__name__}')

    def transpile_Program(self, node):
        for function in node.functions:
            self.transpile(function)
        return '\n'.join(self.output)

    def transpile_Function(self, node):
        # Assuming all functions return int for simplicity
        header = f'int {node.name}(mpz_t result'
        for param in node.params:
            header += f', mpz_t {param}'
        header += ') {\n'
        body = '\n'.join([self.transpile(statement) for statement in node.body])
        self.output.append(header + body + '\n}')
    
    def transpile_IfStatement(self, node):
        condition = self.transpile(node.condition)
        then_branch = self.transpile(node.then_branch)
        return f'if ({condition}) {{\n{then_branch}\n}}\n'

    def transpile_ReturnStatement(self, node):
        expression = self.transpile(node.expression)
        return f'return {expression};'

    def transpile_BinaryOperation(self, node):
        left = self.transpile(node.left)
        right = self.transpile(node.right)
        # Example of handling a binary operation with GMP
        if node.operator == '+':
            return f'mpz_add(result, {left}, {right});'
        elif node.operator == '-':
            return f'mpz_sub(result, {left}, {right});'
        # Add more operators as needed
        else:
            return ''

    def transpile_Number(self, node):
        return f'mpz_set_ui(result, {node.value});'

    def transpile_Identifier(self, node):
        return node.value

if __name__ == '__main__':
    # Assuming `ast_root` is the root of the AST generated by the parser
    transpiler = Transpiler()
    c_code = transpiler.transpile(ast_root)
    
    # Ensure the output directory exists
    output_dir = './output'
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # Write the generated C code to output.c in the output directory
    output_file_path = os.path.join(output_dir, 'output.c')
    with open(output_file_path, 'w') as output_file:
        output_file.write(c_code)
    
    print(f'C code has been written to {output_file_path}')